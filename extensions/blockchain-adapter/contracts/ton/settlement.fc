;; ============================================================================
;; OpenClaw Settlement Contract (TON FunC)
;; 去中心化算力市场结算合约
;; ============================================================================

;; 存储结构
;; storage#_
;;   owner:MsgAddress         所有者地址
;;   total_locked:Coins       总锁定金额
;;   settlement_count:uint32  结算计数
;;   settlements:(HashMapE 256 Settlement)  结算映射

#include "stdlib.fc";

;; ============================================================================
;; 数据结构
;; ============================================================================

;; 结算状态
const int STATUS_LOCKED = 1;
const int STATUS_RELEASED = 2;
const int STATUS_REFUNDED = 3;
const int STATUS_DISPUTED = 4;

;; 操作码
const int op::lock_settlement = 1;
const int op::release_settlement = 2;
const int op::refund_settlement = 3;
const int op::dispute_settlement = 4;

;; 错误码
const int error::unauthorized = 401;
const int error::insufficient_balance = 402;
const int error::settlement_not_found = 404;
const int error::invalid_status = 405;
const int error::timeout_not_reached = 406;

;; 常量
const int DISPUTE_WINDOW = 600;      ;; 10分钟争议窗口
const int TIMEOUT_DURATION = 3600;   ;; 1小时超时

;; ============================================================================
;; 存储管理
;; ============================================================================

;; 加载存储
(slice, int, int, cell) load_data() inline {
  var ds = get_data().begin_parse();
  return (
    ds~load_msg_addr(),     ;; owner
    ds~load_coins(),        ;; total_locked
    ds~load_uint(32),       ;; settlement_count
    ds~load_dict()          ;; settlements
  );
}

;; 保存存储
() save_data(slice owner, int total_locked, int settlement_count, cell settlements) impure inline {
  set_data(
    begin_cell()
      .store_slice(owner)
      .store_coins(total_locked)
      .store_uint(settlement_count, 32)
      .store_dict(settlements)
    .end_cell()
  );
}

;; ============================================================================
;; 结算数据管理
;; ============================================================================

;; 解析结算数据
(int, int, slice, slice, int, int, int) parse_settlement(slice settlement_data) inline {
  return (
    settlement_data~load_uint(8),        ;; status
    settlement_data~load_coins(),        ;; locked_amount
    settlement_data~load_msg_addr(),     ;; payer
    settlement_data~load_msg_addr(),     ;; payee
    settlement_data~load_uint(64),       ;; locked_at
    settlement_data~load_uint(64),       ;; released_at
    settlement_data~load_uint(64)        ;; dispute_window_end
  );
}

;; 构建结算数据
builder build_settlement(
  int status,
  int locked_amount,
  slice payer,
  slice payee,
  int locked_at,
  int released_at,
  int dispute_window_end
) inline {
  return begin_cell()
    .store_uint(status, 8)
    .store_coins(locked_amount)
    .store_slice(payer)
    .store_slice(payee)
    .store_uint(locked_at, 64)
    .store_uint(released_at, 64)
    .store_uint(dispute_window_end, 64);
}

;; 获取结算数据
(int, int, slice, slice, int, int, int) get_settlement(cell settlements, int order_hash) inline {
  var (settlement_slice, found) = settlements.udict_get?(256, order_hash);
  throw_unless(error::settlement_not_found, found);
  return parse_settlement(settlement_slice);
}

;; ============================================================================
;; 核心功能
;; ============================================================================

;; 1. 锁定结算
() lock_settlement(
  slice sender,
  int order_hash,
  int amount,
  slice payee
) impure {
  var (owner, total_locked, settlement_count, settlements) = load_data();

  ;; 检查是否已存在
  var (_, found) = settlements.udict_get?(256, order_hash);
  throw_if(error::invalid_status, found);

  ;; 检查金额
  throw_unless(error::insufficient_balance, amount > 0);

  ;; 创建结算记录
  int now_time = now();
  var settlement = build_settlement(
    STATUS_LOCKED,
    amount,
    sender,
    payee,
    now_time,
    0,
    now_time + TIMEOUT_DURATION
  );

  ;; 保存结算
  settlements~udict_set_builder(256, order_hash, settlement);
  total_locked += amount;
  settlement_count += 1;

  save_data(owner, total_locked, settlement_count, settlements);
}

;; 2. 释放结算
() release_settlement(
  slice sender,
  int order_hash,
  int actual_amount,
  slice signature
) impure {
  var (owner, total_locked, settlement_count, settlements) = load_data();

  ;; 获取结算数据
  var (status, locked_amount, payer, payee, locked_at, _, _) = get_settlement(settlements, order_hash);

  ;; 验证状态
  throw_unless(error::invalid_status, status == STATUS_LOCKED);

  ;; 验证签名者 (必须是payee或owner)
  throw_unless(
    error::unauthorized,
    equal_slices(sender, payee) | equal_slices(sender, owner)
  );

  ;; 验证金额
  throw_unless(error::insufficient_balance, actual_amount <= locked_amount);

  ;; 计算退款
  int refund_amount = locked_amount - actual_amount;

  ;; 发送支付给payee
  if (actual_amount > 0) {
    var msg = begin_cell()
      .store_uint(0x18, 6)
      .store_slice(payee)
      .store_coins(actual_amount)
      .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
      .store_uint(0, 32)  ;; text comment
      .store_slice("Settlement payment")
    .end_cell();
    send_raw_message(msg, 1);  ;; pay fees separately
  }

  ;; 发送退款给payer
  if (refund_amount > 0) {
    var msg = begin_cell()
      .store_uint(0x18, 6)
      .store_slice(payer)
      .store_coins(refund_amount)
      .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
      .store_uint(0, 32)
      .store_slice("Settlement refund")
    .end_cell();
    send_raw_message(msg, 1);
  }

  ;; 更新结算状态
  int now_time = now();
  var settlement = build_settlement(
    STATUS_RELEASED,
    locked_amount,
    payer,
    payee,
    locked_at,
    now_time,
    now_time + DISPUTE_WINDOW
  );

  settlements~udict_set_builder(256, order_hash, settlement);
  total_locked -= locked_amount;

  save_data(owner, total_locked, settlement_count, settlements);
}

;; 3. 退款结算
() refund_settlement(
  slice sender,
  int order_hash
) impure {
  var (owner, total_locked, settlement_count, settlements) = load_data();

  ;; 获取结算数据
  var (status, locked_amount, payer, payee, locked_at, _, dispute_window_end) = get_settlement(settlements, order_hash);

  ;; 验证状态
  throw_unless(error::invalid_status, status == STATUS_LOCKED);

  ;; 验证权限 (payer、owner或超时)
  int now_time = now();
  int is_authorized = equal_slices(sender, payer) | equal_slices(sender, owner);
  int is_timeout = now_time > dispute_window_end;

  throw_unless(error::unauthorized, is_authorized | is_timeout);

  ;; 全额退款给payer
  var msg = begin_cell()
    .store_uint(0x18, 6)
    .store_slice(payer)
    .store_coins(locked_amount)
    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
    .store_uint(0, 32)
    .store_slice("Settlement full refund")
  .end_cell();
  send_raw_message(msg, 1);

  ;; 更新结算状态
  var settlement = build_settlement(
    STATUS_REFUNDED,
    locked_amount,
    payer,
    payee,
    locked_at,
    now_time,
    0
  );

  settlements~udict_set_builder(256, order_hash, settlement);
  total_locked -= locked_amount;

  save_data(owner, total_locked, settlement_count, settlements);
}

;; ============================================================================
;; 主消息处理器
;; ============================================================================

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
  if (in_msg_body.slice_empty?()) {
    return ();  ;; 忽略空消息
  }

  slice cs = in_msg_full.begin_parse();
  int flags = cs~load_uint(4);

  if (flags & 1) {
    return ();  ;; 忽略bounced消息
  }

  slice sender = cs~load_msg_addr();

  ;; 解析操作码
  int op = in_msg_body~load_uint(32);
  int query_id = in_msg_body~load_uint(64);

  ;; 路由到不同操作
  if (op == op::lock_settlement) {
    ;; 锁定结算
    int order_hash = in_msg_body~load_uint(256);
    int amount = in_msg_body~load_coins();
    slice payee = in_msg_body~load_msg_addr();

    lock_settlement(sender, order_hash, amount, payee);
    return ();
  }

  if (op == op::release_settlement) {
    ;; 释放结算
    int order_hash = in_msg_body~load_uint(256);
    int actual_amount = in_msg_body~load_coins();
    slice signature = in_msg_body~load_bits(512);

    release_settlement(sender, order_hash, actual_amount, signature);
    return ();
  }

  if (op == op::refund_settlement) {
    ;; 退款结算
    int order_hash = in_msg_body~load_uint(256);

    refund_settlement(sender, order_hash);
    return ();
  }

  throw(0xffff);  ;; 未知操作
}

;; ============================================================================
;; Get方法 (查询接口)
;; ============================================================================

;; 获取结算信息
(int, int, slice, slice, int, int, int) get_settlement_info(int order_hash) method_id {
  var (_, _, _, settlements) = load_data();
  return get_settlement(settlements, order_hash);
}

;; 获取总锁定金额
int get_total_locked() method_id {
  var (_, total_locked, _, _) = load_data();
  return total_locked;
}

;; 获取结算数量
int get_settlement_count() method_id {
  var (_, _, settlement_count, _) = load_data();
  return settlement_count;
}

;; 获取所有者
slice get_owner() method_id {
  var (owner, _, _, _) = load_data();
  return owner;
}
